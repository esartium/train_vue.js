# Курс по vue.js: конспект

## Способы подключения

+ Подключить удалённый скрипт CDN:

Копируем с сайта с документацией и вставляем перед закрывающим тегом body:

```
<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
```

Затем между этой строчкой и закрывающим тегом body вставляем тег script с подключением js-файла.

В консоли браузера мы можем увидеть соощение о том, что фреймворк vue подключен, а также можем обратиться к глобальному объекту vue (введя "Vue" в консоли браузера) и посмотреть его содержимое.

## Обмен данными между html и js файлами

### Передача данных из js в html:

Для этого нам нужно с помощью метода createApp() проинициализировать само приложение:

```
Vue.createApp(параметр)
```

В качестве параметра этот метод принимает в себя объект, где мы можем настраивать приложение.

Этот объект следует вынести в отдедьную переменную, например:

```
const App = {
    data() {
        return {
            counter: 0
        }
    }
}
```

Здесь data() - это метод, нужный для создания определённых данных; этот метод должен возвращать объект, содержащий пары ключ-значение (ключ - название переменной, значение - её значение).

Чтобы вывести в html-файле значение этого ключа, используем интерполяцию; во vue интерполяция осуществляется с помощью `{{}}`:

```
{{название_ключа}}
```

`{{}}` означает, что в это место нужно вывести некоторый js-код.

Чтобы это сработало, нужно сообщить vue о том, с каким местом в приложении vue будет работать.

Для этого выбираем какой-то html-элемент в качестве корневого. Он будет являться основным узлом в html для работы vue. Дадим этому элементу какой-то id.

Чтобы сообщить js о том, что именно в это место нужно проинициализировать приложение, можно использовать 2 способа.

+ Первый:

Применением метода createApp мы получили объект. Засунем его в переменную:

```
//например:

const app = Vue.createApp(App)
```

И затем применим к этому объекту метод mount, передав ему в качестве параметра css-селектор корневого узла (то есть id объекта, который мы выбрали корневым):

```
const app = Vue.createApp(App)

app.mount('#app')
```

+ Второй:

Не создавать переменную app, чтобы хранить в ней объект, а через точку применить метод к самому объекту:

```
Vue.createApp(App).mount('#app')
```

В объекте, где настраивается приложение, мы можем прописывать больше одной (то есть сколько угодно) ключей, например:

```
const App = {
    data() {
        return {
            counter: 0,
            title: 'Счётчик:'
        }
    }
}
```

В html-коде значение каждого ключа выводится в своих собственных {{}}.

Вне фигурных скобок можно писать любые обычные символы, и они будут обычно выводиться.

###### !

Если ключ имеет значение undefined, то там, где мы его укажем, ничего не будет выведено.

#### Простые действия

Внутри {{}} в html-коде также можно прописывать какие-то простые действия, например:

```
<h1>{{title}} {{ counter + 5 }}</h1>
```

Тогда в html-файле мы получим результат арифметической операции (так можно делать не только со сложением, но и с остальными оперциями, в том числе можно произвести операции с более чем одним действием и скобками).

#### Добавить действие на кнопку

В html-коде с помощью атрибута (вообще это директива, а не атрибут, но так пока понятнее, куда это писать) v-on добавляем слушатель на кнопку:

```
v-on:click
```

Click означает, что слушать он будет клики по кнопке. Далее, не переходя в js-файл (в этом главное преимущество vue), прямо в html-файле прописываем, что будет происходить при клике. 

(но делать всё это нужно в том объекте, который мы выбрали в качестве корневого)

Выглядеть это будет так:

```
<button class="btn primary" v-on:click="counter++">прибавить</button>
```

#### Интерполяция и атрибуты

С помощью интерполяции мы не можем передавать значения в атрибуты.

Чтобы в качестве значения атрибута установить значение какой-то переменной, нужно забайндить данный атрибут к нужной переменной.

Для этого используется директива v-bind.

Пример:

```
<input type="text" v-bind:placeholder="myPlaceholder" />
```

(если открыть код в консоли браузера, директивы там видны не будут, но они есть)

Разница:

В обычных атрибутах прописывается html-код.

В атрибутах, которые мы байндим с помощью v-bind, прописывается js-код. 

### Передача данных из html в js

Например, получение данных из input-поля.

Для этого нужно создать в модели ключ, который будет хранить в себе введённый пользователем в это поле контент; например:

```
const App = {
    data() {
        return {
            myPlaceholder: 'внесите что-то в список',
            title: 'Список:',
            inputValue: ''
        }
    }
}
```

Здесь такой ключ - inputValue.

Затем добавим в модель объект, содержащий в себе методы приложения:

```
const App = {
    data() {
        return {
            myPlaceholder: 'внесите что-то в список',
            title: 'Список:',
            inputValue: ''
        }
    },
    methods: {
        inputChangeHandler (event) {
            console.log('inputChangeHandler', event)
        }
    }
}
```

Метод inputChangeHandler, который здесь прописан, при вводе чего-либо в input-поле выводит в консоль название метода, а также event - объект, описывающий событие, которое произошло - то есть сам ввод текста.

В этом объекте содержится также и само введённое значение. Чтобы его получить, нужно обратиться через точку:

```
const App = {
    data() {
        return {
            myPlaceholder: 'внесите что-то в список',
            title: 'Список:',
            inputValue: ''
        }
    },
    methods: {
        inputChangeHandler (event) {
            console.log('inputChangeHandler', event.target.value)
        }
    }
}
```

Вызывается этот метод в html-файле через директиву v-on:

```
    <input 
        type="text" 
        v-bind:placeholder="myPlaceholder" 
        v-bind:value="inputValue" 
        v-on:input="inputChangeHandler"
    />
```

Введённое в input-поле значение можно засунуть в переменную. Для этого в методе модели через ключевое слово this обрщаемся к самой этой модели и присваиваем значение пустой переменной, которую создали ранее:

```
const App = {
    data() {
        return {
            myPlaceholder: 'внесите что-то в список',
            title: 'Список:',
            inputValue: ''
        }
    },
    methods: {
        inputChangeHandler (event) {
            console.log('inputChangeHandler', event.target.value);
            this.inputValue = event.target.value;
        }
        
    }
}
```

Таким образом, мы с помощью vue.js реализовали двустороннее связывание.

#### Создать список из массива

Пусть в модели у нас есть массив notes с уже заданными значениями:

```
const App = {
    data() {
        return {
            myPlaceholder: 'внесите что-то в список',
            title: 'Список:',
            inputValue: '',
            notes: ['note1','note2']
        }
    },
    methods: {
        inputChangeHandler (event) {
            console.log('inputChangeHandler', event.target.value);
            this.inputValue = event.target.value;
        }
        
    }
}
```

Тогда в html-файле мы можем вывести его элементы, используя интерполяцию:

```
<ul class="list">
            <li class="list-item">
                {{notes[0]}}
            </li>
            <li class="list-item">
                {{notes[1]}}
            </li>
        </ul>
```

Однако это не всегда удобно.

Другой способ это сделать:

Сделаем цикл. Для этого найдёи элемент, который будет являться итерируемым; то есть это тот элемент, который будет повторяться в цикле внутри шаблона html. Пропишем этому элементу директиу v-for.

Пример:

```
<ul class="list">
            <li class="list-item" v-for="i in notes">
                {{ i }}
            </li>
</ul>
```

Здесь мы в качестве итерируемого выбрали элемент li;

Значение директивы v-for: i - это переменная цикла (просто придумали на месте, до этоого нигде не фигурировала, и вне цикла доступна не будет), notes - название массива; вместо in также можно использовать of (в конексте vue.js это одно и то же)

#### Создать список из введённых пользователем значений

Пусть у нас есть форма, куда пользователь вводит какой-то текст с клавиатуры. Нам нужно сделать так, чтобы при нажатии кнопки "добавить" введённые им значения вносились в список.

Для этого нам нужно обработать нажатие на кнопку через директиву v-on:

```
<button class="btn" v-on:click="addNewNote">добавить</button>
```

В качестве значения атрибута click мы записали вызов функции. Эту функцию описываем в методах модели:

```
const App = {
    data() {
        return {
            myPlaceholder: 'внесите что-то в список',
            title: 'Список:',
            inputValue: '',
            notes: ['note1','note2']
        }
    },
    methods: {
        inputChangeHandler (event) {
            console.log('inputChangeHandler', event.target.value);
            this.inputValue = event.target.value;
        },

        addNewNote() {
            this.notes.push(this.inputValue)
        } 
    }
}
```

Чтобы поле вводе очищалось после добавления каждого элемента, а не хранило в себе введённый текст, прописываем в функции:

```
addNewNote() {
            this.notes.push(this.inputValue)
            this.inputValue = ''
        } 
```

#### Удалить элемент списка

Нам нужно создать кнопку, удаляющую элемент из списка.

Для этого, чтобы определить, какой именно элемент списка нужно удалить, нам надо работать с индексами массива.

Чтобы получить индекс элемента и, например, вывести его вместе с элементами списка, меняем цикл следующим образом:

```
<li class="list-item" v-for="(i, idx) in notes">
    {{ i }} , индекс: {{idx}}
    <button class="btn danger" v-on:click="deleteNote(idx, $event)"> удалить </button>
</li>
```

Здесь мы создали кнопку, отвечающую за удаление, и указали функцию, которая это делает. Этой функции мы передаём индекс idx элемента массива; также этот индекс мы здесь выводим вместе с каждым элементом.

Метод для удаления выглядит так:

```
deleteNote(idx, $event) {
        this.notes.splice(idx, 1)
}
```

В параметрах метода мы указали, что удаляем 1 элемент, начиная с элемента idx.

(этот метод прописывается в методах модели)

### Модификаторы

Пусть есть задача сделать так, чтобы данная функция вызывалась не только при нажатии мышкой находящейся на странице кнопки, но и при нажатии, например, кнопки enter на клавиатуре.

#### Без использования модификаторов: 

Сделать так, чтобы в консоли выводилось, какую кнопку мы только что нажали, можно, добавив новое действие keypress через директиву v-on:

```
<input 
    type="text" 
    v-bind:placeholder="myPlaceholder" 
    v-bind:value="inputValue" 
    v-on:input="inputChangeHandler"
    v-on:keypress="inputKeyPress"
/>
```
И создав в методах модели функцию, при нажатии любой клавиши выводящую в консоль то, какую кнопку мы только что нажали:
```
methods: {
        inputChangeHandler (event) {
            console.log('inputChangeHandler', event.target.value);
            this.inputValue = event.target.value;
        },

        addNewNote () {
            this.notes.push(this.inputValue)
            this.inputValue = ''
        },

        inputKeyPress (event) {
            console.log(event.key)
        }
        
    }
```

Теперь, чтобы при нажатии определённой клавиши выполнялась функция, мы вызываем эту функцию внутри функции, которая обрабатывает событие keypress:

```
inputKeyPress (event) {
    if (event.key == 'Enter') {
                this.addNewNote()
    }
}
```

#### С использованием модификаторов:

Если обрабатывать данное событие при помощи модификаторов, то функцию, обрабатывающую нажатие клавиши, не обязательно отдельно прописывать.

Достаточно прописыать следующее:

```
<input 
    type="text" 
    v-bind:placeholder="myPlaceholder" 
    v-bind:value="inputValue" 
    v-on:input="inputChangeHandler"
    v-on:keypress.enter="addNewNote"
/>
```

Здесь мы уже показали, что обрабатываем нажатие на enter, и тут же показываем, как именно - вызываем нужный нам метод (раньше мы вызывали его внутри созданной нами функции; теперь её создавать не нужно)

#### Директива v-if

Например, если мы хотим показывать список только тогда, когда он не пустой.

```
<ul class="list" v-if="notes.length !==0">
    <li class="list-item" v-for="(i, idx) in notes">
                {{ i }} , индекс: {{idx}}
                <button class="btn danger" v-on:click="deleteNote(idx, $event)"> удалить </button>
    </li>
</ul>
    <div v-if="notes.length == 0"> Список пуст </div>
```

Как это работает: тот тег, к которму мы добавляем данную директиву, отображается, если выполнено прописанное в значении данной директивы условие. То есть: if то-то, тогда показывается содержимое тега.

Здесь мы, по сути, реализовали if-else, но прописали два разных if с противоположными условиями. Вместо ещё одного if мы могли использовать else:

```
<ul class="list" v-if="notes.length !==0">
        <li class="list-item" v-for="(i, idx) in notes">
                {{ i }} , индекс: {{idx}}
                <button class="btn danger" v-on:click="deleteNote(idx, $event)"> удалить </button>
        </li>
</ul>
        <div v-else> Список пуст </div>
```

Существует также v-else-if. Работает по аналогии с обычным else if: находится между if и else, должен содержать в себе условие (как и if; else условий не содержит)

###### Сделать так, чтобы при нажатии кнопки строка вставлялась тольео тогда, когда она не пустая:

Меняем функцию добавления заметки, добавляя условие:

```
addNewNote () {
    if (this.inputValue !== '') {
        this.notes.push(this.inputValue)
        this.inputValue = ''
    }
},
```

## Работа с методами в интерполяции

В интерполяции также можно вызывать методы.

В интерполяции можно использовать что угодно, если это можно привести к строке. То есть, если метод возвращает нам строку, мы можем использовать его в интерполяции.

Например: нужно сделать так, чтобы заметки отображались в верхнем регистре.

В js:

```
toUpperCase (item) {
    return item.toUpperCase()
}
```

В html:

```
<li class="list-item" v-for="(i, idx) in notes">
    Элемент номер {{idx}}: {{ toUpperCase(i) }}; 
        <button class="btn danger" v-on:click="deleteNote(idx, $event)"> удалить </button>
</li>
```

## Ярлыки

Используются вместо названия директивы.

Вместо v-bind можно использовать двоеточие.

Вместо v-on можно использовать знак @.

(см. index3.html)

### Computed

Мы хотим, чтобы выводилось число элементов списка. Это легко сделать:

```
<ul class="list" v-if="notes.length !==0">
    <li class="list-item" v-for="(i, idx) in notes">
        Элемент номер {{idx}}: {{ toUpperCase(i) }}; 
                <button class="btn danger" @click="deleteNote(idx, $event)"> удалить </button>
    </li>
        <hr>
    <li>
        <strong>Элементов в списке: {{notes.length}}</strong>
    </li>
</ul>
```

Теперь мы хотим выводить еще и число элементов списка, умноженное, например, на 100.

```
<ul class="list" v-if="notes.length !==0">
    <li class="list-item" v-for="(i, idx) in notes">
        Элемент номер {{idx}}: {{ toUpperCase(i) }}; 
                <button class="btn danger" @click="deleteNote(idx, $event)"> удалить </button>
    </li>
        <hr>
    <li>
        <strong>Элементов в списке: {{notes.length}}</strong> | Умноженное на 100: {{ multilpliedCount() }}
    </li>
</ul>
```

Если мы пропишем вывод в консоль в этом методе, то увидим, сколько раз вызывается этот метод. Он вызывается при добавлении элемента в список, удалении элемента из списка, а также вызывается при вводе каждого символа в input-поле. Это создаёт проблему производительности.

Кроме уже рассмотренных data и methods в модели существует также объект computed. Его содержимое - функции, которые вызываются (в html-коде) не как обычные функции - параметры им не передаются, и скобки ставить не надо. Функция, имеющая такое же тело, как и та, о которой говорилось выше, но созданная в computed, будет вызываться только при нажатии кнопки, то есть либо при добавлении элемента, либо при удалении элемента.

Computed-свойства по сути являются геттерами/сеттерами; зависят от каких-либо переменных, существующих в модели; если внутри приложения есть какие-то переменные, от которых нужно вычислить какой-то результат, в целях оптимизации это делают в computed-свойстве.

### Watch

Такое же свойство, как data, methods, computed и др.

Позволяет следить за изменением какой-либо переменной.

Например, можно сделать так, чтобы при каждом изменении переменной inputValue в консоли появлялось сообщение об этом:

```
watch: {
    inputValue(value) {
        console.log('input value changed', value)
    }
}
```

Также в функциях, прописанных в watch, можно сделать какую-нибудь валидацию, например, после того, как введённая пользователем строка достигнет более чем 10 символов, в строке появится сообщение, и вводить какой-то текст перестанет быть возможным:

```
watch: {
    inputValue(value) {
        if (value.length > 10) {
            this.inputValue = 'не пиши сюда больше'
        }
            
            console.log('input value changed', value)
        }
    }
```

То есть, раз мы в таких функциях отслеживаем изменения переменной, то можем прописать условие "если эта переменая изменится таким-то образом, то с ней произойдёт то-то"

### Оптимизация двустороннего связывания

С помощью директивы v-model мы можем указать, какая модель потребуется

Она заменит немалое количество функционала, который был прописан нами вручную.

## Стили

Во vue мы всё ещё может пользоваться обычными атрибутами для добавления стилей 

Например, атрибут style:

```
<h2 style="color: aquamarine;">inputValue: {{inputValue}}</h2>
```

Но это не динамично.

Зато можно сделать так, чтобы какие-то стили применялись при выполнении определённого условия.

Для этого нам нужно забайндить атрибут style. Тогда он будет описываться следующим образом:

```
<h1 :style="{
    color: 'red'
}">
```

Так как мы забайндили этот атрибут, то теперь внутри него мы пишем js-код, то есть набор пар ключ-значение. Ключами будут определённые свойства стилей (например, цвет, как здесь).

Чтобы свойство стилей изменялось динамически, в эту конструкцию нужно добавить условие:

```
<h1 :style="{
    color: inputValue.length < 5 ? 'red' : 'darkred'
}">
{{title}}
</h1>
```

Здесь мы показали, что если длина строки меньше 5 (знак вопроса значит, что мы как бы спрсили: меньше 5 ли она? тогда red), то цвет такой-то, а иначе: такой-то.

В js для свойств, состоящих из нескольаих слов, используется camelCase.

Если нужно указать несколько свойств, они перечисляются через запятую. Пример:

```
<h1 :style="{
    color: inputValue.length < 5 ? 'red' : 'darkred',
        fontSize: inputValue.length < 5 ? '25px' : '35px'
}">
```

## Классы

Рассмотрим динамическое взаимодействие с классами.

Первый способ.

Для этого нужно забайндить атрибут class html-объекта и точно так же добавить к нему условие через тернарное выражение, как мы делали с атрибутом style.

```
<li class="list-item" v-for="(i, idx) in notes">
    <span :class="i.length > 5 ? 'primary' : 'bold'"> 
    Элемент номер {{idx}}: {{ toUpperCase(i) }}; 
    </span>
</li>
```

То есть так же прописываем: в данном случае: если длина одного из элементов списка больше пяти, то класс у span такой, else - другой.

Второй способ.

Байндим атрибут class нужного тега.

```
<span :class="{
            'primary':true,
            'bold':i.length > 5
}"> 
Элемент номер {{idx}}: {{ toUpperCase(i) }}; 
</span>
```

Здесь класс, для которого установлено значение true, будет классом этого тега по умолчанию, а класс, для которого указано условие, будет классом этого тега (класс по умолчанию не исчезнет, новый класс просто добавится, и у тега будет два класса) при выполнении условия.

Третий способ.

Байндим атрибут class и передаём ему массив, где в качестве элеентов мы можем передавать классы или объекты.

Мы можем передать просто строку с названием класса, но также можем и добавить условие.

```
<span :class="[
        'bold', {'primary':i.length > 5}
]"> 
Элемент номер {{idx}}: {{ toUpperCase(i) }}; 
</span>
```

Здесь первыц элемент массива - класс по умолчанию, второй элемент - условие, а также название класса, который, помимо класса по умолчанию, также устанавливается для данного тега при выполнении условия.




























