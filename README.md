# Курс по vue.js: конспект

## Способы подключения

+ Подключить удалённый скрипт CDN:

Копируем с сайта с документацией и вставляем перед закрывающим тегом body:

```
<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
```

Затем между этой строчкой и закрывающим тегом body вставляем тег script с подключением js-файла.

В консоли браузера мы можем увидеть соощение о том, что фреймворк vue подключен, а также можем обратиться к глобальному объекту vue (введя "Vue" в консоли браузера) и посмотреть его содержимое.

## Обмен данными между html и js файлами

### Передача данных из js в html:

Для этого нам нужно с помощью метода createApp() проинициализировать само приложение:

```
Vue.createApp(параметр)
```

В качестве параметра этот метод принимает в себя объект, где мы можем настраивать приложение.

Этот объект следует вынести в отдедьную переменную, например:

```
const App = {
    data() {
        return {
            counter: 0
        }
    }
}
```

Здесь data() - это метод, нужный для создания определённых данных; этот метод должен возвращать объект, содержащий пары ключ-значение (ключ - название переменной, значение - её значение).

Чтобы вывести в html-файле значение этого ключа, используем интерполяцию; во vue интерполяция осуществляется с помощью `{{}}`:

```
{{название_ключа}}
```

`{{}}` означает, что в это место нужно вывести некоторый js-код.

Чтобы это сработало, нужно сообщить vue о том, с каким местом в приложении vue будет работать.

Для этого выбираем какой-то html-элемент в качестве корневого. Он будет являться основным узлом в html для работы vue. Дадим этому элементу какой-то id.

Чтобы сообщить js о том, что именно в это место нужно проинициализировать приложение, можно использовать 2 способа.

+ Первый:

Применением метода createApp мы получили объект. Засунем его в переменную:

```
//например:

const app = Vue.createApp(App)
```

И затем применим к этому объекту метод mount, передав ему в качестве параметра css-селектор корневого узла (то есть id объекта, который мы выбрали корневым):

```
const app = Vue.createApp(App)

app.mount('#app')
```

+ Второй:

Не создавать переменную app, чтобы хранить в ней объект, а через точку применить метод к самому объекту:

```
Vue.createApp(App).mount('#app')
```

В объекте, где настраивается приложение, мы можем прописывать больше одной (то есть сколько угодно) ключей, например:

```
const App = {
    data() {
        return {
            counter: 0,
            title: 'Счётчик:'
        }
    }
}
```

В html-коде значение каждого ключа выводится в своих собственных {{}}.

Вне фигурных скобок можно писать любые обычные символы, и они будут обычно выводиться.

###### !

Если ключ имеет значение undefined, то там, где мы его укажем, ничего не будет выведено.

#### Простые действия

Внутри {{}} в html-коде также можно прописывать какие-то простые действия, например:

```
<h1>{{title}} {{ counter + 5 }}</h1>
```

Тогда в html-файле мы получим результат арифметической операции (так можно делать не только со сложением, но и с остальными оперциями, в том числе можно произвести операции с более чем одним действием и скобками).

#### Добавить действие на кнопку

В html-коде с помощью атрибута (вообще это директива, а не атрибут, но так пока понятнее, куда это писать) v-on добавляем слушатель на кнопку:

```
v-on:click
```

Click означает, что слушать он будет клики по кнопке. Далее, не переходя в js-файл (в этом главное преимущество vue), прямо в html-файле прописываем, что будет происходить при клике. 

(но делать всё это нужно в том объекте, который мы выбрали в качестве корневого)

Выглядеть это будет так:

```
<button class="btn primary" v-on:click="counter++">прибавить</button>
```

#### Интерполяция и атрибуты

С помощью интерполяции мы не можем передавать значения в атрибуты.

Чтобы в качестве значения атрибута установить значение какой-то переменной, нужно забайндить данный атрибут к нужной переменной.

Для этого используется директива v-bind.

Пример:

```
<input type="text" v-bind:placeholder="myPlaceholder" />
```

(если открыть код в консоли браузера, директивы там видны не будут, но они есть)

Разница:

В обычных атрибутах прописывается html-код.

В атрибутах, которые мы байндим с помощью v-bind, прописывается js-код. 

### Передача данных из html в js

Например, получение данных из input-поля.

Для этого нужно создать в модели ключ, который будет хранить в себе введённый пользователем в это поле контент; например:

```
const App = {
    data() {
        return {
            myPlaceholder: 'внесите что-то в список',
            title: 'Список:',
            inputValue: ''
        }
    }
}
```

Здесь такой ключ - inputValue.

Затем добавим в модель объект, содержащий в себе методы приложения:

```
const App = {
    data() {
        return {
            myPlaceholder: 'внесите что-то в список',
            title: 'Список:',
            inputValue: ''
        }
    },
    methods: {
        inputChangeHandler (event) {
            console.log('inputChangeHandler', event)
        }
    }
}
```

Метод inputChangeHandler, который здесь прописан, при вводе чего-либо в input-поле выводит в консоль название метода, а также event - объект, описывающий событие, которое произошло - то есть сам ввод текста.

В этом объекте содержится также и само введённое значение. Чтобы его получить, нужно обратиться через точку:

```
const App = {
    data() {
        return {
            myPlaceholder: 'внесите что-то в список',
            title: 'Список:',
            inputValue: ''
        }
    },
    methods: {
        inputChangeHandler (event) {
            console.log('inputChangeHandler', event.target.value)
        }
    }
}
```

Вызывается этот метод в html-файле через директиву v-on:

```
    <input 
        type="text" 
        v-bind:placeholder="myPlaceholder" 
        v-bind:value="inputValue" 
        v-on:input="inputChangeHandler"
    />
```

Введённое в input-поле значение можно засунуть в переменную. Для этого в методе модели через ключевое слово this обрщаемся к самой этой модели и присваиваем значение пустой переменной, которую создали ранее:

```
const App = {
    data() {
        return {
            myPlaceholder: 'внесите что-то в список',
            title: 'Список:',
            inputValue: ''
        }
    },
    methods: {
        inputChangeHandler (event) {
            console.log('inputChangeHandler', event.target.value);
            this.inputValue = event.target.value;
        }
        
    }
}
```

Таким образом, мы с помощью vue.js реализовали двустороннее связывание.

#### Создать список из массива

Пусть в модели у нас есть массив notes с уже заданными значениями:

```
const App = {
    data() {
        return {
            myPlaceholder: 'внесите что-то в список',
            title: 'Список:',
            inputValue: '',
            notes: ['note1','note2']
        }
    },
    methods: {
        inputChangeHandler (event) {
            console.log('inputChangeHandler', event.target.value);
            this.inputValue = event.target.value;
        }
        
    }
}
```

Тогда в html-файле мы можем вывести его элементы, используя интерполяцию:

```
<ul class="list">
            <li class="list-item">
                {{notes[0]}}
            </li>
            <li class="list-item">
                {{notes[1]}}
            </li>
        </ul>
```

Однако это не всегда удобно.

Другой способ это сделать:

Сделаем цикл. Для этого найдёи элемент, который будет являться итерируемым; то есть это тот элемент, который будет повторяться в цикле внутри шаблона html. Пропишем этому элементу директиу v-for.

Пример:

```
<ul class="list">
            <li class="list-item" v-for="i in notes">
                {{ i }}
            </li>
</ul>
```

Здесь мы в качестве итерируемого выбрали элемент li;

Значение директивы v-for: i - это переменная цикла (просто придумали на месте, до этоого нигде не фигурировала, и вне цикла доступна не будет), notes - название массива; вместо in также можно использовать of (в конексте vue.js это одно и то же)

#### Создать список из введённых пользователем значений

Пусть у нас есть форма, куда пользователь вводит какой-то текст с клавиатуры. Нам нужно сделать так, чтобы при нажатии кнопки "добавить" введённые им значения вносились в список.

Для этого нам нужно обработать нажатие на кнопку через директиву v-on:

```
<button class="btn" v-on:click="addNewNote">добавить</button>
```

В качестве значения атрибута click мы записали вызов функции. Эту функцию описываем в методах модели:

```
const App = {
    data() {
        return {
            myPlaceholder: 'внесите что-то в список',
            title: 'Список:',
            inputValue: '',
            notes: ['note1','note2']
        }
    },
    methods: {
        inputChangeHandler (event) {
            console.log('inputChangeHandler', event.target.value);
            this.inputValue = event.target.value;
        },

        addNewNote() {
            this.notes.push(this.inputValue)
        } 
    }
}
```

Чтобы поле вводе очищалось после добавления каждого элемента, а не хранило в себе введённый текст, прописываем в функции:

```
addNewNote() {
            this.notes.push(this.inputValue)
            this.inputValue = ''
        } 
```

#### Удалить элемент списка

Нам нужно создать кнопку, удаляющую элемент из списка.

Для этого, чтобы определить, какой именно элемент списка нужно удалить, нам надо работать с индексами массива.

Чтобы получить индекс элемента и, например, вывести его вместе с элементами списка, меняем цикл следующим образом:

```
<li class="list-item" v-for="(i, idx) in notes">
    {{ i }} , индекс: {{idx}}
    <button class="btn danger" v-on:click="deleteNote(idx, $event)"> удалить </button>
</li>
```

Здесь мы создали кнопку, отвечающую за удаление, и указали функцию, которая это делает. Этой функции мы передаём индекс idx элемента массива; также этот индекс мы здесь выводим вместе с каждым элементом.

Метод для удаления выглядит так:

```
deleteNote(idx, $event) {
        this.notes.splice(idx, 1)
}
```

В параметрах метода мы указали, что удаляем 1 элемент, начиная с элемента idx.

(этот метод прописывается в методах модели)

### Модификаторы

Пусть есть задача сделать так, чтобы данная функция вызывалась не только при нажатии мышкой находящейся на странице кнопки, но и при нажатии, например, кнопки enter на клавиатуре.

#### Без использования модификаторов: 

Сделать так, чтобы в консоли выводилось, какую кнопку мы только что нажали, можно, добавив новое действие keypress через директиву v-on:

```
<input 
    type="text" 
    v-bind:placeholder="myPlaceholder" 
    v-bind:value="inputValue" 
    v-on:input="inputChangeHandler"
    v-on:keypress="inputKeyPress"
/>
```
И создав в методах модели функцию, при нажатии любой клавиши выводящую в консоль то, какую кнопку мы только что нажали:
```
methods: {
        inputChangeHandler (event) {
            console.log('inputChangeHandler', event.target.value);
            this.inputValue = event.target.value;
        },

        addNewNote () {
            this.notes.push(this.inputValue)
            this.inputValue = ''
        },

        inputKeyPress (event) {
            console.log(event.key)
        }
        
    }
```

Теперь, чтобы при нажатии определённой клавиши выполнялась функция, мы вызываем эту функцию внутри функции, которая обрабатывает событие keypress:

```
inputKeyPress (event) {
    if (event.key == 'Enter') {
                this.addNewNote()
    }
}
```

#### С использованием модификаторов:

Если обрабатывать данное событие при помощи модификаторов, то функцию, обрабатывающую нажатие клавиши, не обязательно отдельно прописывать.

Достаточно прописыать следующее:

```
<input 
    type="text" 
    v-bind:placeholder="myPlaceholder" 
    v-bind:value="inputValue" 
    v-on:input="inputChangeHandler"
    v-on:keypress.enter="addNewNote"
/>
```

Здесь мы уже показали, что обрабатываем нажатие на enter, и тут же показываем, как именно - вызываем нужный нам метод (раньше мы вызывали его внутри созданной нами функции; теперь её создавать не нужно)

#### Директива v-if

Например, если мы хотим показывать список только тогда, когда он не пустой.

```
<ul class="list" v-if="notes.length !==0">
    <li class="list-item" v-for="(i, idx) in notes">
                {{ i }} , индекс: {{idx}}
                <button class="btn danger" v-on:click="deleteNote(idx, $event)"> удалить </button>
    </li>
</ul>
    <div v-if="notes.length == 0"> Список пуст </div>
```

Как это работает: тот тег, к которму мы добавляем данную директиву, отображается, если выполнено прописанное в значении данной директивы условие. То есть: if то-то, тогда показывается содержимое тега.

Здесь мы, по сути, реализовали if-else, но прописали два разных if с противоположными условиями. Вместо ещё одного if мы могли использовать else:

```
<ul class="list" v-if="notes.length !==0">
        <li class="list-item" v-for="(i, idx) in notes">
                {{ i }} , индекс: {{idx}}
                <button class="btn danger" v-on:click="deleteNote(idx, $event)"> удалить </button>
        </li>
</ul>
        <div v-else> Список пуст </div>
```

Существует также v-else-if. Работает по аналогии с обычным else if: находится между if и else, должен содержать в себе условие (как и if; else условий не содержит)

###### Сделать так, чтобы при нажатии кнопки строка вставлялась тольео тогда, когда она не пустая:

Меняем функцию добавления заметки, добавляя условие:

```
addNewNote () {
    if (this.inputValue !== '') {
        this.notes.push(this.inputValue)
        this.inputValue = ''
    }
},
```

## Работа с методами в интерполяции

В интерполяции также можно вызывать методы.

В интерполяции можно использовать что угодно, если это можно привести к строке. То есть, если метод возвращает нам строку, мы можем использовать его в интерполяции.

Например: нужно сделать так, чтобы заметки отображались в верхнем регистре.

В js:

```
toUpperCase (item) {
    return item.toUpperCase()
}
```

В html:

```
<li class="list-item" v-for="(i, idx) in notes">
    Элемент номер {{idx}}: {{ toUpperCase(i) }}; 
        <button class="btn danger" v-on:click="deleteNote(idx, $event)"> удалить </button>
</li>
```

## Ярлыки

Используются вместо названия директивы.

Вместо v-bind можно использовать двоеточие.

Вместо v-on можно использовать знак @.

(см. index3.html)

### Computed

Мы хотим, чтобы выводилось число элементов списка. Это легко сделать:

```
<ul class="list" v-if="notes.length !==0">
    <li class="list-item" v-for="(i, idx) in notes">
        Элемент номер {{idx}}: {{ toUpperCase(i) }}; 
                <button class="btn danger" @click="deleteNote(idx, $event)"> удалить </button>
    </li>
        <hr>
    <li>
        <strong>Элементов в списке: {{notes.length}}</strong>
    </li>
</ul>
```

Теперь мы хотим выводить еще и число элементов списка, умноженное, например, на 100.

```
<ul class="list" v-if="notes.length !==0">
    <li class="list-item" v-for="(i, idx) in notes">
        Элемент номер {{idx}}: {{ toUpperCase(i) }}; 
                <button class="btn danger" @click="deleteNote(idx, $event)"> удалить </button>
    </li>
        <hr>
    <li>
        <strong>Элементов в списке: {{notes.length}}</strong> | Умноженное на 100: {{ multilpliedCount() }}
    </li>
</ul>
```

Если мы пропишем вывод в консоль в этом методе, то увидим, сколько раз вызывается этот метод. Он вызывается при добавлении элемента в список, удалении элемента из списка, а также вызывается при вводе каждого символа в input-поле. Это создаёт проблему производительности.

Кроме уже рассмотренных data и methods в модели существует также объект computed. Его содержимое - функции, которые вызываются (в html-коде) не как обычные функции - параметры им не передаются, и скобки ставить не надо. Функция, имеющая такое же тело, как и та, о которой говорилось выше, но созданная в computed, будет вызываться только при нажатии кнопки, то есть либо при добавлении элемента, либо при удалении элемента.

Computed-свойства по сути являются геттерами/сеттерами; зависят от каких-либо переменных, существующих в модели; если внутри приложения есть какие-то переменные, от которых нужно вычислить какой-то результат, в целях оптимизации это делают в computed-свойстве.

### Watch

Такое же свойство, как data, methods, computed и др.

Позволяет следить за изменением какой-либо переменной.

Например, можно сделать так, чтобы при каждом изменении переменной inputValue в консоли появлялось сообщение об этом:

```
watch: {
    inputValue(value) {
        console.log('input value changed', value)
    }
}
```

Также в функциях, прописанных в watch, можно сделать какую-нибудь валидацию, например, после того, как введённая пользователем строка достигнет более чем 10 символов, в строке появится сообщение, и вводить какой-то текст перестанет быть возможным:

```
watch: {
    inputValue(value) {
        if (value.length > 10) {
            this.inputValue = 'не пиши сюда больше'
        }
            
            console.log('input value changed', value)
        }
    }
```

То есть, раз мы в таких функциях отслеживаем изменения переменной, то можем прописать условие "если эта переменая изменится таким-то образом, то с ней произойдёт то-то"

### Оптимизация двустороннего связывания

С помощью директивы v-model мы можем указать, какая модель потребуется

Она заменит немалое количество функционала, который был прописан нами вручную.

## Стили

Во vue мы всё ещё может пользоваться обычными атрибутами для добавления стилей 

Например, атрибут style:

```
<h2 style="color: aquamarine;">inputValue: {{inputValue}}</h2>
```

Но это не динамично.

Зато можно сделать так, чтобы какие-то стили применялись при выполнении определённого условия.

Для этого нам нужно забайндить атрибут style. Тогда он будет описываться следующим образом:

```
<h1 :style="{
    color: 'red'
}">
```

Так как мы забайндили этот атрибут, то теперь внутри него мы пишем js-код, то есть набор пар ключ-значение. Ключами будут определённые свойства стилей (например, цвет, как здесь).

Чтобы свойство стилей изменялось динамически, в эту конструкцию нужно добавить условие:

```
<h1 :style="{
    color: inputValue.length < 5 ? 'red' : 'darkred'
}">
{{title}}
</h1>
```

Здесь мы показали, что если длина строки меньше 5 (знак вопроса значит, что мы как бы спрсили: меньше 5 ли она? тогда red), то цвет такой-то, а иначе: такой-то.

В js для свойств, состоящих из нескольаих слов, используется camelCase.

Если нужно указать несколько свойств, они перечисляются через запятую. Пример:

```
<h1 :style="{
    color: inputValue.length < 5 ? 'red' : 'darkred',
        fontSize: inputValue.length < 5 ? '25px' : '35px'
}">
```

## Классы

Рассмотрим динамическое взаимодействие с классами.

Первый способ.

Для этого нужно забайндить атрибут class html-объекта и точно так же добавить к нему условие через тернарное выражение, как мы делали с атрибутом style.

```
<li class="list-item" v-for="(i, idx) in notes">
    <span :class="i.length > 5 ? 'primary' : 'bold'"> 
    Элемент номер {{idx}}: {{ toUpperCase(i) }}; 
    </span>
</li>
```

То есть так же прописываем: в данном случае: если длина одного из элементов списка больше пяти, то класс у span такой, else - другой.

Второй способ.

Байндим атрибут class нужного тега.

```
<span :class="{
            'primary':true,
            'bold':i.length > 5
}"> 
Элемент номер {{idx}}: {{ toUpperCase(i) }}; 
</span>
```

Здесь класс, для которого установлено значение true, будет классом этого тега по умолчанию, а класс, для которого указано условие, будет классом этого тега (класс по умолчанию не исчезнет, новый класс просто добавится, и у тега будет два класса) при выполнении условия.

Третий способ.

Байндим атрибут class и передаём ему массив, где в качестве элеентов мы можем передавать классы или объекты.

Мы можем передать просто строку с названием класса, но также можем и добавить условие.

```
<span :class="[
        'bold', {'primary':i.length > 5}
]"> 
Элемент номер {{idx}}: {{ toUpperCase(i) }}; 
</span>
```

Здесь первыц элемент массива - класс по умолчанию, второй элемент - условие, а также название класса, который, помимо класса по умолчанию, также устанавливается для данного тега при выполнении условия.

#### Другие способы заданияметода data() в модели

Рассмотренный ранее вид:

```
data() {
    return {
        ...
    }
}
```

Его можно также указывать в виде стрелочной функции:

```
data: () => {
    return {
       ...     
    }
}
```

В стрелочной фунции мы можем опустить слово return и вместо него поставить (скобки). Скобки означают, что мы возвращаем объект.

```
data: () => ({
        title: 'тайтл'
    })
```

(Это не особенность vue, а особенность js)

## Директивы

Директивы - это некоторые вспомогательные элементы в шаблоне; начинаются с "v-".

Внутри директивы всегда пишется js-код.

Список базовых встроенных директив находится в документации в разделе Built-in Directives.

#### Рассмотрим некоторые из них.

#### v-text

То же самое, что интерполяция.

То есть это:

```
<h1 v-text="title">  </h1>
```

Равносильно обычной интерполяции:

```
<h1> {{ title }} </h1>
```

#### v-once

Позволяет выводить контент всего один раз, вне зависимости от того, изменяли мы этот контент или нет.

Пример синтаксиса:

```
<h2 v-once> {{title}} </h2>
```

Суть на примере:

Пусть у нас есть два html-объекта. Для первого v-once не задан, для второго - задан. Также есть кнопка, нажатие по которой изменяет значение переменной. 

```
<h1 v-text="title"> </h1>
    <h2 v-once> {{title}} </h2>
       <button class="btn" @click="title = 'не тайтл'">изменить название</button>
```

Изменяемая по нажатию кнопки переменная выводится в обоих тегах. Однако после нажатия изменится лишь содержимое того тега, для которого не прописан v-once. Тот, для которого v-once прописан, выведет переменную всего один раз, а далее, что бы ни происходило, меняться она не будет.

#### v-pre

Данная директива означает, что содержимое тега, для которого она указана, не нужно компилировать, а нужно вывести так, как она есть.

Пример:

```
<h2 v-pre> {{title}} </h2>
```

Такой код выведет нам {{title}} простым текстом на странице.

#### v-html

Вывод html-кода, описанного в js-коде.

Пусть в модели у нас есть переменная, содержащая в себе html-код:

```
Vue.createApp({
     data: () => ({
        title: 'тайтл',
        myHtml: '<h1>заголовок</h1>'
    })
}).mount('#app')
```

Чтобы вывести эту переменную в html-файле, используется директива v-html (без неё вывелся бы просто html-код, а не результат его выполнения):

```
<div v-html="myHtml"></div>
```

#### v-cloak

Нужна, чтобы при загрузке страницы ничего не дёргалось и не было видно, как сначала прогружается DOM-дерево html, а уже потом страница принимает нормальный вид с подключением js-файла.

Данная директива вешается на определённый тег и описывается не на месте, где мы её прописали, а ранее, в head.

Чтобы решить описанную выше проблему загрузки, можно повесить эту директиву на элемент, который мы выбрали корневым.

Пример:

```
<div class="container pt-5" id="app" v-cloak>
```

Описание директивы в head:

```
<style>
    [v-cloak] {
        display: none;
    }
</style>
```

Здесь мы показали, что тот элемент, у которого есть эта директива, не отображается (пока не загрузится).

Суть работы этой директивы в том, что она существует до момента, пока приложение не будет загружено, а после этого момента убирается.

## Ещё немного о циклах и v-for

##### без массивов

Чтобы использовать такой цикл, не обязательно создавать массив и делать итерацию по нему.

Пример:

```
<ul class="list">
    <li class="list-item" v-for="i in 4"> {{i}} </li>
</ul>
```

Здесь мы, сделали так, чтобы индекс выводился 4 раза.

Такой цикл работает так же, как и те, что работают с массивами, и делать с ним можно всё то же самое.

Также через v-for мы можем взаимодействовать, например, с такими объектами, как person здесь:

```
Vue.createApp({
     data: () => ({
        title: 'тайтл',
        myHtml: '<h1>заголовок</h1>',
        person: {
            firstName: 'chelik',
            lastName: 'chelikov',
            age: '500'
        }
    })
}).mount('#app')
```

Тогда мы можем сделать итерацию по такому объекту и вывести его в шаблон:

```
<ul class="list">
    <li class="list-item" v-for="value in person"> {{value}} </li>
</ul>
```

Получить индекс элемента такого объекта можно так:

```
<ul class="list">
    <li class="list-item" v-for="(value, key) in person"> {{key}}: {{value}} </li>
</ul>
```
Здесь мы вывели этот ключ в шаблон.

##### с массивом

Сделать так, чтобы элементы удалялись при клике на них, можно не только через функцию в js-файле, но и прямо на месте, в html-файле.

```
<ul class="list">
    <li 
        class="list-item" 
        v-for="(item, i) in items"
        @click="items.splice(i, 1)"
    >
        {{i}}: {{item}} 
    </li>
</ul>
```

Здесь items - просто массив:

```
Vue.createApp({
     data: () => ({
        items: [1, 2, 3, 4, 5, 6]
    })
}).mount('#app')
```

Сделать так, чтобы список показывался, только если он не пустой, а если пустой, то показывалась бы надпись:

```
<ul class="list" v-if="items.length !== 0 ">
        <li 
           class="list-item" 
           v-for="(item, i) in items"
           @click="items.splice(i, 1)"
        >
            {{i}}: {{item}} 
        </li>
</ul>
       <h3 v-else=""> вы всё удалили </h3>
```

Директива v-if работает таким образом, что, пока не выполнено условие, элемент не просто не показывается на странице, но ещё и не показывается в консоли; его просто нет в DOM-дереве.

Чтобы элемент был скрыт, но существовал в DOM-дереве, используется директива v-show:

```
<ul class="list" v-if="items.length !== 0 ">
    <li 
           class="list-item" 
           v-for="(item, i) in items"
           @click="items.splice(i, 1)"
    >
        {{i}}: {{item}} 
    </li>
</ul>
    <h3 v-show="items.length == 0"> вы всё удалили </h3>
```

v-show здесь записан вместо v-else, однако это скорее аналог v-if. То есть мы просто прописали для обоих элементов условие, при котором они будут показаны на странице.

### Модификаторы событий

Пусть у нас есть такой код в html-файле:

```
<ul class="list" v-if="items.length !== 0 ">
    <li 
           class="list-item" 
           v-for="(item, i) in items"
           @click="items.splice(i, 1)"
    >
        {{i}}: {{item}} &nbsp;
        <input type="text">
    </li>
</ul>
       <h3 v-show="items.length == 0"> вы всё удалили </h3>
```

(&nbsp - пробел)

Здесь мы, как описывалось выше, создали список, где при клике на элемент он удаляется. Здесь мы добавили к каждому элементу списка input-поле. Теперь, когда мы кликаем на сам элемент, он удаляется. Так и надо. Но нам надо, чтобы он не удалялся при клике на input-поле.

Без vue, в обычноь js, мы бы решили эту проблему с помощью метода stopPropagation:

В html:

```
<input type="text" @click="stopPropagation">
```

В js:

```
methods: {
    stopPropagation(event) {
            event.stopPropagation()
    }
}
```

Методами vue это решается использованием модификатора stop (ничего кроме этого нигде прописывать не надо):

```
<input type="text" @click.stop>
```

Этот модификатор говорит vue, что нужно остановить погружение события.

#### Баг

Теперь, когда мы вписываем что-то в input-поле, а затем удаляем элемент, содержащий это input-поле, текст, который мы ввели, перебрасывается на input-поле следующего элемента списка.

Это происходит из-за того, что в ядре vue есть концепт virtual dom, необходиый для оптимизации взаимодействия с DOM-деревом. 

Как это пофиксить:

```
<li 
    class="list-item" 
    v-for="(item, i) in items"
    @click="items.splice(i, 1)"
    :key="item"
>
        {{i}}: {{item}} &nbsp;
        <input type="text" @click.stop>
</li>
```

Мы добавили атрибут key и передали ему уникальный идентификатор - сам элемент массива - item (индекс передавать нельзя - будет ещё один баг). Key точно показывает vue, какой именно элемент нужно удалить. Для работы с циклами этот атрибут очень важен.

### Фильтрация данных внутри цикла

Пример: нужно вывести только чётные элементы массива.

Для этого используется computed-свойство:

```
computed: {
    evenItems() {
        return this.items.filter(i => i % 2 === 0)
    }
}
```

Здесь мы создали функцию, которая возвращает нам массив, полученный применением функции filter к массиву items, который мы создали ранее. Теперь, чтобы вывести только чётные элементы массива, просто делаем итерацию по этому массиву:

```
v-for="(item, i) in evenItems"
```

## Ещё про модификаторы

Существует 3 вида модификаторов. Ранее мы разбирали stop. Он относится к модификаторам событий. Посмотреть, какие ешё модифиаторы относятся к этому типу, можно в документации в разделе Event Modifiers.

Модификаторы можно чейнить (то есть объединять).

Пример:

```
<div class="form-control">
        <input type="text" @keyup.shift.enter="addItem" ref="myInput">
</div>
```

```
methods: {
    addItem() {
        this.items.unshift(this.$refs.myInput.value)
    }
},
```

Здесь мы показали, что при нажатии shift+enter будет вызываться метод addItem, записывающий введённый в input-поле текст в переменную, указанную в атрибуте ref.

### !

Если мы хотим сделать так, чтобы одно событие вызывало несколько методов, просто в этом событии (как атрибуте) перечисляем их через запятую.









